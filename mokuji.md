# 2 コードとプロジェクトの構成
- 1 意図しない変数スコープ
- 2 ネストが深い
- 3 initの使い方
- 4 getter, setter
- 5 interfaceの使い方
- 6 interfaceを生産者側で定義するケースは望ましくない
- 7 interfaceを返す関数は望ましくない　interfaceは引数で使用する
- 8 anyは望ましくない
- 9 genericsをいつ使うか
- 10 埋め込みの正しい使いかた
    埋め込みとサブクラスの違いは　レシーバーがサブクラスの場合はサブクラスになるのに対して、埋め込みの場合はそのまま親クラスになる
    フィールドやメソッドを外部に公開するかどうかで判断しても良いかも
- 11 構造体の設定パターン
    builder
    functional options おすすめ　
- 12 プロジェクトの誤った構成
- 13 ユーティリティーパッケージの作成
    具体的な名前にすべき utils=x
- 14 パッケージ名の衝突を無視する
    変数名とパッケージ名が衝突など
- 15 コードのドキュメントがない
    公開要素はコメントを書く
- 16 リンターを使わない = x
    静的解析ツールは積極的に使うべき

# 3 データ型
- 17 8進数
- 18 オーバーフロー
- 19 浮動小数点数の扱い
    比較など注意
- 20 スライスの長さと容量
- 21 スライスの初期化 効率的に初期化する
- 22 nilスライスと空スライスの違い
    nilスライスは割当が発生しないので使い分ける P82

- 23 スライスが空か否かを検査しない
    len(s) == 0 で判定する
- 24 スライスのコピー
    copy()を使う。容量を確保する
- 25 スライスのappendによる予期しない副作用
    append()は元のスライスを変更するので注意
- 26 スライスとメモリリーク 
    スライスの一部だけを参照している場合は、残りの要素もGCによって削除されない
- 27 非効率なmapの初期化 サイズを指定する
- 28 マップのメモリリーク
- 29 値の比較の誤り

# 4 制御構文
- 30 rangeループでは値がコピーされる
- 31 rangeループでの関数の引数の評価方法
- 32 rangeループでポインタ要素を使う影響
- 33 マップの反復処理で誤った仮定をする
     途中で要素を追加した時の動作
- 34 breakの仕組みを理解
- 35 deferをループで使う場合の動作

# 5 文字列
- 36 ルーンの概念
    Unicodeのコードポイントを表す
- 37 不正確な文字列反復
- 38 trim関数の誤用
- 39 文字列の結合
    strings.Builderを使う
- 40 無駄な文字列変換
    bytes.Bufferを使う
- 41 部分文字列とメモリリーク

# 6 関数とメソッド
- 42 ポインタレシーバーか値レシーバーか
    ポインタレシーバーはメソッド内でレシーバーの値を変更する場合に使う
    メソッドはレシーバーを第一引数とする関数のような扱い
- 43 名前付き結果パラメーターの誤用
- 44 名前付き結果パラメーターの副作用
    ゼロ値で初期化される
- 45 nilレシーバーを返す
    nilポインタとnilは違う
- 46 ファイル名を関数の入力として使う
    テストが書くにくい
- 47 defer の引数やレシーバーの評価
    deferは関数の終了時に実行される

# 7 エラー管理
エラーをラップする！！
- 48 パニックを発生させてしまう
    panicは通常の制御の流れを中断してしまう
    純粋なプログラマのエラーを知らせる時に使う程度。ステータスコードがおかしいなど
    必須の依存関係の初期化に失敗した時など
    ほとんどの場合はエラーを返す
- 49 エラーをラップすべき時を無視してしまう 
　　　エラーをラップするとは、元々のエラーも扱えるようにすること
    P163で使い分けが書いてある
- 50 エラー型を不正に検査する
    ラップした場合の検査方法
    As()を使う 型を検査する
- 51 エラー値を不正確に検査する
    Is()を使う 値を検査する
- 52 エラーを２度処理してしまう
- 53 エラーを処理しない
    _ := notify()　のようにエラーを無視する場合でも _ で変数定義する
    無視する理由もコメントで残す
- 54 defer でエラーを処理しない
    func() { _ := defer close() }の形にする

# 8 並行処理　　基礎編
- 55 並行と並列を混同する
    並列は人が複数いる
    並行は人が一人で複数のことをする
    並行処理は一度に多くを扱うこと、並列処理は一度に多くを行うこと
- 56 並行処理は常に高速であると考える
    高速とは限らない
    スレッドの切り替えはコストがかかる
- 57 チャネルとミューテックスの使い分けに悩む
    チャネルはデータの受け渡し　ストリーム通信
    ミューテックスはデータの保護　データの同期
- 58 強豪状態を理解していない
    -raceフラグを使って実行すると強豪状態がわかる
    atomicを使うか、mutexを使うか、チャネルを使うか
- 59 作業負荷の種類による並行処理の影響を理解していない 
    CPUバウンドとIOバウンド
    CPUバウンドはCPUの処理能力に依存する
    IOバウンドはIOの処理能力に依存する
    CPUバウンドは並行処理で高速化できる
    IOバウンドは並行処理で高速化できない
- 60 Goのコンテキストを誤解する
    デッドライン
    キャンセル
    他の値を伝える
        トレースIDを持たせるなど

# 9 並行処理 実践編 難しい
- 61 不適切なコンテキストの伝播
    コンテキストの電波はわかりにくいバグになりやすい
- 62 ゴルーチンを停止するタイミングを分からずに起動する
    ゴルーチンリークにつながる
- 63 ゴルーチンとループ変数の扱いに注意しない
- 64 selectとチャネルを使って、決定的な動作を期待する
- 65 通知チャネルを使わない
    チャネルを使って、ゴルーチンの終了を通知する
    struct{}{}を使う
- 66 nilチャネルを使っていない
    nilチャネルは役に立つ
    永遠にブロックする
- 67 チャネルの大きさに迷う
    バッファなしチャネルは同期的に動作する
        通知、同期、キャンセル
    バッファありチャネルは非同期的に動作する
        ワーカープール、レートリミットなど
    大きさを決めるときはベンチマークを取って根拠を持つ
- 68 文字列のフォーマットで起こり得る副作用を忘れる
    データ競合とデッドロック
- 69 appenndでのデータ競合を生み出す
    チャネルを使う
- 70 スライスとマップで誤ったmutexを使う
    sync.Mapを使う
- 71 sync.WaitGroupの誤用
    sync.WaitGroupは値渡しする
- 72 sync.Condの存在を忘れている
    チャネルでは実現できない同期を実現する
- 73 errorGroupを使わない
    便利に使える
    並行処理をするときは基本使う
- 74 syncパッケージの型をコピーする
    sync.Mutexは参照で渡す。コピーしてはいけない
    データ競合の原因になる

# 10 標準ライブラリ
- 75 誤った時間の長さを提供する
- 76 time.Afterとメモリリーク
    time.AfterrはSleepと違い、処理を分岐させることができる（時間が経過しなかったらなど）
    chの受信によってメモリが膨れ上がる
- 77 よくあるJsonの間違い
    埋め込みによっての挙動の違い
    モノトニックな時間の扱い
        ロケーションを指定する 
    any mapの扱い
        数値はfloat64になる 

- 78 　よくあるSQLの間違い
    必ずしもコネクションを確立しないことを忘れる
    コネクションプールをを忘れている
    本番ではコネクションプールを使う P266
    プリペアドステートメントを使わない
        効率性とセキュリティの点から必ずすべき P266
    null値の間違った扱い
        sql.NullStringを使う
    行の反復処理の時にエラーを無視する
        rows.Err()を使う
    
- 79 一時的な資源をクローズしない
    httpBodyをクローズする
        サーバー側のリクエストのボディはサーバー側が自動でクローズする
    sql.Rowsをクローズする
        sql.Rowsはクローズする必要がある
    os.Fileをクローズする
        os.Fileはクローズする必要がある
        GCによってクローズされるが、いつ呼び出されるかわからないので明示的にクローズする

- 80 httpリクエストに応答した後にreturnを忘れる

- 81 デフォルトのHTTPクライアントとサーバーを使う
    クライアント
    デフォルトの状態だとタイムアウトなどを指定していないので本番では好ましくない
        終了しないリクエストを受け付けてしまう
    4つのタイムアウトを設定できる P278
    
    サーバー
    3つのタイムアウトを設定できる P280

# 11 テスト