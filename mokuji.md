# 2 コードとプロジェクトの構成
- 1 意図しない変数スコープ
- 2 ネストが深い
- 3 initの使い方
- 4 getter, setter
- 5 interfaceの使い方
- 6 interfaceを生産者側で定義するケースは望ましくない
- 7 interfaceを返す関数は望ましくない　interfaceは引数で使用する
- 8 anyは望ましくない
- 9 genericsをいつ使うか
- 10 埋め込みの正しい使いかた
    埋め込みとサブクラスの違いは　レシーバーがサブクラスの場合はサブクラスになるのに対して、埋め込みの場合はそのまま親クラスになる
    フィールドやメソッドを外部に公開するかどうかで判断しても良いかも
- 11 構造体の設定パターン　○
    builder
    functional options おすすめ　
- 12 プロジェクトの誤った構成
- 13 ユーティリティーパッケージの作成
    具体的な名前にすべき utils=x
- 14 パッケージ名の衝突を無視する
    変数名とパッケージ名が衝突など
- 15 コードのドキュメントがない
    公開要素はコメントを書く
- 16 リンターを使わない = x
    静的解析ツールは積極的に使うべき

# 3 データ型
- 17 8進数
- 18 オーバーフロー
- 19 浮動小数点数の扱い
    比較など注意
- 20 スライスの長さと容量
- 21 スライスの初期化 効率的に初期化する　○
- 22 nilスライスと空スライスの違い　　○
    nilスライスは割当が発生しないので使い分ける P82

- 23 スライスが空か否かを検査しない　○
    len(s) == 0 で判定する
- 24 スライスのコピー　○
    copy()を使う。容量を確保する
- 25 スライスのappendによる予期しない副作用　○
    append()は元のスライスを変更するので注意
- 26 スライスとメモリリーク 　○
    スライスの一部だけを参照している場合は、残りの要素もGCによって削除されない
- 27 非効率なmapの初期化 サイズを指定する
- 28 マップのメモリリーク
- 29 値の比較の誤り

# 4 制御構文
- 30 rangeループでは値がコピーされる
- 31 rangeループでの関数の引数の評価方法
- 32 rangeループでポインタ要素を使う影響
- 33 マップの反復処理で誤った仮定をする
     途中で要素を追加した時の動作
- 34 breakの仕組みを理解
- 35 deferをループで使う場合の動作

# 5 文字列
- 36 ルーンの概念
    Unicodeのコードポイントを表す
- 37 不正確な文字列反復
- 38 trim関数の誤用
- 39 文字列の結合
    strings.Builderを使う
- 40 無駄な文字列変換
    bytes.Bufferを使う
- 41 部分文字列とメモリリーク

# 6 関数とメソッド
- 42 ポインタレシーバーか値レシーバーか
    ポインタレシーバーはメソッド内でレシーバーの値を変更する場合に使う
    メソッドはレシーバーを第一引数とする関数のような扱い
- 43 名前付き結果パラメーターの誤用
- 44 名前付き結果パラメーターの副作用
    ゼロ値で初期化される
- 45 nilレシーバーを返す
    nilポインタとnilは違う
- 46 ファイル名を関数の入力として使う
    テストが書くにくい
- 47 defer の引数やレシーバーの評価
    deferは関数の終了時に実行される

# 7 エラー管理
エラーをラップする！！
- 48 パニックを発生させてしまう
    panicは通常の制御の流れを中断してしまう
    純粋なプログラマのエラーを知らせる時に使う程度。ステータスコードがおかしいなど
    必須の依存関係の初期化に失敗した時など
    ほとんどの場合はエラーを返す
- 49 エラーをラップすべき時を無視してしまう 
　　　エラーをラップするとは、元々のエラーも扱えるようにすること
    P163で使い分けが書いてある
- 50 エラー型を不正に検査する
    ラップした場合の検査方法
    As()を使う 型を検査する
- 51 エラー値を不正確に検査する
    Is()を使う 値を検査する
- 52 エラーを２度処理してしまう
- 53 エラーを処理しない
    _ := notify()　のようにエラーを無視する場合でも _ で変数定義する
    無視する理由もコメントで残す
- 54 defer でエラーを処理しない
    func() { _ := defer close() }の形にする

# 8 並行処理　　基礎編
- 55 並行と並列を混同する
    並列は人が複数いる
    並行は人が一人で複数のことをする
    並行処理は一度に多くを扱うこと、並列処理は一度に多くを行うこと
- 56 並行処理は常に高速であると考える
    高速とは限らない
    スレッドの切り替えはコストがかかる
- 57 チャネルとミューテックスの使い分けに悩む
    チャネルはデータの受け渡し　ストリーム通信
    ミューテックスはデータの保護　データの同期
- 58 強豪状態を理解していない
    -raceフラグを使って実行すると強豪状態がわかる
    atomicを使うか、mutexを使うか、チャネルを使うか
- 59 作業負荷の種類による並行処理の影響を理解していない 
    CPUバウンドとIOバウンド
    CPUバウンドはCPUの処理能力に依存する
    IOバウンドはIOの処理能力に依存する
    CPUバウンドは並行処理で高速化できる
    IOバウンドは並行処理で高速化できない
- 60 Goのコンテキストを誤解する
    デッドライン
    キャンセル
    他の値を伝える
        トレースIDを持たせるなど

# 9 並行処理 実践編 難しい
- 61 不適切なコンテキストの伝播
    コンテキストの電波はわかりにくいバグになりやすい
- 62 ゴルーチンを停止するタイミングを分からずに起動する
    ゴルーチンリークにつながる
- 63 ゴルーチンとループ変数の扱いに注意しない
- 64 selectとチャネルを使って、決定的な動作を期待する
- 65 通知チャネルを使わない
    チャネルを使って、ゴルーチンの終了を通知する
    struct{}{}を使う
- 66 nilチャネルを使っていない
    nilチャネルは役に立つ
    永遠にブロックする
- 67 チャネルの大きさに迷う
    バッファなしチャネルは同期的に動作する
        通知、同期、キャンセル
    バッファありチャネルは非同期的に動作する
        ワーカープール、レートリミットなど
    大きさを決めるときはベンチマークを取って根拠を持つ
- 68 文字列のフォーマットで起こり得る副作用を忘れる
    データ競合とデッドロック
- 69 appenndでのデータ競合を生み出す
    チャネルを使う
- 70 スライスとマップで誤ったmutexを使う
    sync.Mapを使う
- 71 sync.WaitGroupの誤用
    sync.WaitGroupは値渡しする
- 72 sync.Condの存在を忘れている
    チャネルでは実現できない同期を実現する
- 73 errorGroupを使わない
    便利に使える
    並行処理をするときは基本使う
- 74 syncパッケージの型をコピーする
    sync.Mutexは参照で渡す。コピーしてはいけない
    データ競合の原因になる

# 10 標準ライブラリ
- 75 誤った時間の長さを提供する
- 76 time.Afterとメモリリーク
    time.AfterrはSleepと違い、処理を分岐させることができる（時間が経過しなかったらなど）
    chの受信によってメモリが膨れ上がる
- 77 よくあるJsonの間違い
    埋め込みによっての挙動の違い
    モノトニックな時間の扱い
        ロケーションを指定する 
    any mapの扱い
        数値はfloat64になる 

- 78 　よくあるSQLの間違い
    必ずしもコネクションを確立しないことを忘れる
    コネクションプールをを忘れている
    本番ではコネクションプールを使う P266
    プリペアドステートメントを使わない
        効率性とセキュリティの点から必ずすべき P266
    null値の間違った扱い
        sql.NullStringを使う
    行の反復処理の時にエラーを無視する
        rows.Err()を使う
    
- 79 一時的な資源をクローズしない
    httpBodyをクローズする
        サーバー側のリクエストのボディはサーバー側が自動でクローズする
    sql.Rowsをクローズする
        sql.Rowsはクローズする必要がある
    os.Fileをクローズする
        os.Fileはクローズする必要がある
        GCによってクローズされるが、いつ呼び出されるかわからないので明示的にクローズする

- 80 httpリクエストに応答した後にreturnを忘れる

- 81 デフォルトのHTTPクライアントとサーバーを使う
    クライアント
    デフォルトの状態だとタイムアウトなどを指定していないので本番では好ましくない
        終了しないリクエストを受け付けてしまう
    4つのタイムアウトを設定できる P278
    
    サーバー
    3つのタイムアウトを設定できる P280

# 11 テスト
- 82 テストを分類しない
    単体テスト
    結合テスト
    E2Eテスト
    (機能テスト)
    (ベンチマークテスト)
    テストの分類を明確にすることで、テストの実行時間を短縮できる
    ・ビルドタグで分類
        //go:build test
        //go:build !test 否定で書くと省く事ができる
    ・環境変数を使って分類
    ・ショートモードで分類
        go test -short

- 83 -raceフラグを有効にしない
    go test -race ./...

- 84 テスト実行モードを使わない
    ・t.Parallel()を使う
    ・-shuffleフラグを使う
        テストの実行順をランダムにする。依存関係を調査できる。実行順に依存すべきでない。単体で独立すべき
        go test -shuffle=on -v .

- 85 テーブル駆動テストを使わない
```
	for name, tt := range tests {
		// t.Parallel()を使うと、テストを並列実行できる
		// クロージャが誤った値をキャプチャしないようにするために、テストの引数を渡す
		// 以下のようにする事で、個別のクロージャは自身のttにアクセスする
		tt := tt
		// サブテスト
		t.Run(name, func(t *testing.T) {
			t.Parallel()
			got := removeNewLineSuffixes(tt.input)
			if got != tt.expected {
				t.Errorf("got: %s, expected: %s", got, tt.expected)
			}
		})
	}
```
- 86  単体テストでスリープする = x
    ?

- 87 timeAPIを効率よく使わない　○
    現在時刻に依存するテストの場合は、time.Now()を使うとテストが失敗する可能性がある
    ・現在時刻を返す関数のスタブを使う　

- 88 テスト用ユーティリティパッケージを使っていない
    httptest
        クライアントとサーバーをテストできるパッケージ
    iotest
        テスト用のio.Readerとio.Writerを提供するパッケージ

- 89 不正確なベンチマークを書く　あまり読み込んでいない
関数名の先頭にBenchmarkをつける
    timerをリセットしたり一時停止したりしない    
    マイクロベンチマークについて間違った仮定をする
    コンパイラの最適化に注意を払わない
    観察者効果に騙される

- 90 Goのテスト機能を全て使いこなしていない
    コードカバレッジ
        go test -cover ./...
    　別のパッケージからテストを実行する
        package main_test
    ユーティリティ関数
        t.Helper()
        引数testing.Tを渡す
            err管理を簡素化できる
    事前準備と事後処理
        t.Cleanup()
        TestMain() 
            m.Run()を呼び出す

# 12 最適化　 まとめを読む方がいい
正しく作る、わかりやすく作る、簡潔にする、早くする、この順番で考える
- 91 CPUキャッシュを理解していない
    CPUアーキテクチャ
        レジスタ
        L1キャッシュ
        L2キャッシュ
        L3キャッシュ
        メモリ
    キャッシュライン
    構造体のスライスかスライスの構造体
        スライスの構造体の方がキャッシュ効率が良い
    予測可能性
    キャッシュ配置ポリシー ?

- 92 偽共有につながる並行コードを書く
    性能低下の原因になる
        パディングを持たせる
        アルゴリズムを高速化
            チャネルを使う

- 93 命令レベルの並行処理を考慮しない ?
- 94 データアライメントを意識していない
    データの割り当てを整えること。型によって割り当てられるメモリのサイズが異なる
- 95 スタックとヒープを理解していない 
    ポインタを使う事が多いとヒープに割り当てられる。ポインタを返す事が、必ずしも高速化につながるわけではない
        エスケープ分析
            go build -gcflags '-m=2' で確認できる

- 96 割り当てを減らす方法を知らない
    ヒープ割り当てを減らす事は、性能向上につながる
    P359
    APIの変更
        スライスを返す系の関数はヒープ割り当てが発生する
    コンパイラの最適化
    sync.Pool
        キャッシュではない
        共通のオブジェクトを使いまわすためのもの

- 97 インライン展開に頼らない
    関数呼び出しを関数本体に展開すること。コンパイラによって自動的に行われる
    P364　メリット

- 98 Goの診断ツールを使っていない ?
    プロファイリング pprof P 367 
        CPUプロファイリング
            go tool pprof -http=:8080 cpu.prof
        ヒーププロファイリング
            go tool pprof -http=:8080 -diff_base heap.prof heap2.prof
        ゴルーチンプロファイリング
        ブロックプロファイリング
        ミューテックスプロファイリング
    実行トレーサー
        go test -bench=. -v -trace=trace.out


- 99 GCの仕組みを理解していない
    ガベージコレクタの概念
        マークアンドスイープ
            GCトレース
    GCの例 P379グラフ        
        

- 100 DockerやK8sでGoを実行することによる影響を理解していない
    CPUコア