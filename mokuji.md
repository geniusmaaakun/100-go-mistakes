# 2 コードとプロジェクトの構成
- 1 意図しない変数スコープ
- 2 ネストが深い
- 3 initの使い方
- 4 getter, setter
- 5 interfaceの使い方
- 6 interfaceを生産者側で定義するケースは望ましくない
- 7 interfaceを返す関数は望ましくない　interfaceは引数で使用する
- 8 anyは望ましくない
- 9 genericsをいつ使うか
- 10 埋め込みの正しい使いかた
    埋め込みとサブクラスの違いは　レシーバーがサブクラスの場合はサブクラスになるのに対して、埋め込みの場合はそのまま親クラスになる
    フィールドやメソッドを外部に公開するかどうかで判断しても良いかも
- 11 構造体の設定パターン
    builder
    functional options おすすめ　
- 12 プロジェクトの誤った構成
- 13 ユーティリティーパッケージの作成
    具体的な名前にすべき utils=x
- 14 パッケージ名の衝突を無視する
    変数名とパッケージ名が衝突など
- 15 コードのドキュメントがない
    公開要素はコメントを書く
- 16 リンターを使わない = x
    静的解析ツールは積極的に使うべき

# 3 データ型
- 17 8進数
- 18 オーバーフロー
- 19 浮動小数点数の扱い
    比較など注意
- 20 スライスの長さと容量
- 21 スライスの初期化 効率的に初期化する
- 22 nilスライスと空スライスの違い
    nilスライスは割当が発生しないので使い分ける P82

- 23 スライスが空か否かを検査しない
    len(s) == 0 で判定する
- 24 スライスのコピー
    copy()を使う。容量を確保する
- 25 スライスのappendによる予期しない副作用
    append()は元のスライスを変更するので注意
- 26 スライスとメモリリーク 
    スライスの一部だけを参照している場合は、残りの要素もGCによって削除されない
- 27 非効率なmapの初期化 サイズを指定する
- 28 マップのメモリリーク
- 29 値の比較の誤り

# 4 制御構文
- 30 rangeループでは値がコピーされる
- 31 rangeループでの関数の引数の評価方法
- 32 rangeループでポインタ要素を使う影響
- 33 マップの反復処理で誤った仮定をする
     途中で要素を追加した時の動作
- 34 breakの仕組みを理解
- 35 deferをループで使う場合の動作

# 文字列